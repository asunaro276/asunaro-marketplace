---
name: component-tdd
description: Vue、React、Astroなどのフロントエンドコンポーネントを作成する際に使用するスキル。テスト駆動開発のアプローチでコンポーネントを実装し、仕様のヒアリングからテスト作成、実装、検証までの一連のワークフローをガイドする。
---

# コンポーネントテスト駆動開発

## 概要

フロントエンドコンポーネント（Vue、React、Astroなど）をテスト駆動開発（TDD）のアプローチで作成するためのスキル。ユーザーからの仕様ヒアリング、テスト設計、実装、検証までの一連のワークフローを提供し、品質の高いコンポーネント開発を支援する。

## いつ使用するか

以下のような状況でこのスキルを使用する：
- 新しいフロントエンドコンポーネントを作成する必要がある場合
- 既存のコンポーネントに新機能を追加する場合
- コンポーネントのリファクタリングを行う場合
- テストが不足しているコンポーネントにテストを追加する場合

## ワークフロー

### ステップ1: プロジェクト分析

コンポーネント作成を開始する前に、プロジェクトの構造とフレームワークを分析する。

1. **フレームワークの特定**
   - package.jsonや設定ファイルを確認し、使用されているフレームワーク（Vue、React、Astroなど）を特定
   - プロジェクトのバージョン情報も確認

2. **プロジェクト構造の把握**
   - コンポーネントの配置場所（例：`src/components/`, `app/components/`など）を確認
   - テストファイルの配置規則（例：`*.spec.ts`, `*.test.tsx`など）を確認
   - 既存のコンポーネントの構造やパターンを参考にする

3. **プロジェクト固有の慣習を確認**
   - プロジェクトローカルの `${pwd}/.claude/skills/component-tdd/references/project-convention.md` を参照し、プロジェクト固有のHTML/CSS慣習、コンポーネント設計パターン、テストパターンを確認
   - ファイルが存在しない場合は、`/fit-to-project component-tdd` コマンドを実行してプロジェクト固有の skill を作成
   - プロジェクト固有の skill が作成されていない場合は、コードベースから慣習を推測し、必要に応じてユーザーに確認

### ステップ2: 仕様のヒアリング

ユーザーから詳細な仕様を引き出し、実装の方向性を明確にする。

1. **基本的な質問**
   - コンポーネントの目的と役割は何か？
   - どのような見た目（UI）が必要か？
   - どのような振る舞い（動作）が必要か？
   - どのようなpropsやstateが必要か？

2. **技術的な質問**
   - 他のコンポーネントとの連携はあるか？
   - APIとの通信は必要か？
   - ルーティングとの連携は必要か？
   - フォームの場合、バリデーションロジックは？

3. **要件の確認**
   - ヒアリングした内容をまとめ、ユーザーに確認
   - 不明点や曖昧な点があれば追加で質問

### ステップ3: コンポーネントの準備

テスト作成の前に、コンポーネントファイルの準備を行う。

1. **既存コンポーネントの確認**
   - 対象のコンポーネントファイルが既に存在するか確認
   - 存在する場合は、現在の実装を確認

2. **新規コンポーネントの作成**
   - コンポーネントが存在しない場合、空のコンポーネントファイルを作成
   - プロジェクトの命名規則とディレクトリ構造に従う
   - 最小限のボイラープレートコード（基本的な構造）を記述

例（React/TypeScript）：
```typescript
import React from 'react';

interface MyComponentProps {
  // TODO: propsの型定義
}

export const MyComponent: React.FC<MyComponentProps> = (props) => {
  return (
    <div>
      {/* TODO: 実装 */}
    </div>
  );
};
```

例（Vue 3/TypeScript）：
```vue
<script setup lang="ts">
interface Props {
  // TODO: propsの型定義
}

const props = defineProps<Props>();
</script>

<template>
  <div>
    <!-- TODO: 実装 -->
  </div>
</template>

<style scoped>
/* TODO: スタイル */
</style>
```

### ステップ4: コンポーネントテストの作成

仕様に基づいてコンポーネントテストを作成する。この段階ではテストが通る必要はない。

1. **テスト対象の決定**
   - 複数のコンポーネントが関連する場合、機能単位で最も大きいコンポーネント（親コンポーネント）にのみテストを書く
   - 子コンポーネントは親コンポーネントのテストでカバーされる

2. **テストファイルの作成**
   - プロジェクトのテストファイル命名規則に従ってテストファイルを作成
   - テストフレームワーク（Vitest、Jest、Testing Libraryなど）の設定を確認

3. **テストケースの設計**
   - レンダリングテスト：コンポーネントが正しくレンダリングされるか
   - Props テスト：propsが正しく渡され、表示されるか
   - イベントテスト：ユーザーインタラクション（クリック、入力など）が正しく動作するか
   - 状態管理テスト：stateの変更が正しく反映されるか
   - 条件付きレンダリングテスト：条件に応じて表示が変わるか

4. **期待結果の定義**
   - 各テストケースで期待される結果を明確に定義
   - アサーション（expect文）を記述

5. **モックの最小化**
   - APIアクセスとルーター以外は基本的にモックしない
   - モックが必要な場合は、後で追加することを前提に TODO コメントを残す

例（React Testing Library/Vitest）：
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  it('正しくレンダリングされる', () => {
    render(<MyComponent title="テスト" />);
    expect(screen.getByText('テスト')).toBeInTheDocument();
  });

  it('ボタンをクリックすると状態が変更される', () => {
    render(<MyComponent />);
    const button = screen.getByRole('button', { name: 'クリック' });
    fireEvent.click(button);
    expect(screen.getByText('クリック済み')).toBeInTheDocument();
  });

  // TODO: APIモックが必要な場合はここに追加
});
```

### ステップ5: コンポーネントの実装

テストを満たす形でコンポーネントのHTML、CSS、ロジックを実装する。

1. **既存コードの尊重**
   - 既にHTML/CSSが書かれている場合は、極力変更を最小限にする
   - プロジェクト固有のスタイル慣習（プロジェクトローカルの `${pwd}/.claude/skills/component-tdd/references/project-convention.md`）に従う

2. **段階的な実装**
   - 1つのテストケースずつ実装していく
   - テストを実行しながら進める（Red → Green → Refactor サイクル）

3. **HTML構造の実装**
   - セマンティックなHTMLを心がける
   - アクセシビリティを考慮（適切なaria属性、role属性など）

4. **CSSスタイルの実装**
   - プロジェクトのスタイリング手法（CSS Modules、Tailwind CSS、Styled Componentsなど）に従う
   - レスポンシブデザインを考慮

5. **ロジックの実装**
   - イベントハンドラーの実装
   - 状態管理ロジックの実装
   - propsの受け渡しとバリデーション

### ステップ6: テストの実行と調整

テストを実行し、すべてのテストが通るまでコンポーネントを調整する。

1. **テストの実行**
   - テストコマンドを実行（例：`npm test`, `pnpm test`, `vitest`など）
   - 失敗したテストケースを確認

2. **エラーの分析**
   - テスト失敗の原因を特定
   - 実装の問題か、テストの問題かを判断

3. **調整と再実行**
   - コンポーネントの実装を調整
   - 必要に応じてテストケースも調整（仕様の解釈が誤っていた場合など）
   - テストを再実行

4. **繰り返し**
   - すべてのテストが通るまで調整と再実行を繰り返す

5. **リファクタリング**
   - テストが通った後、コードの品質を向上させる
   - 重複コードの削減、可読性の向上など
   - リファクタリング後もテストが通ることを確認

### ステップ7: 最終確認

実装が完了したら、最終的な確認を行う。

1. **テストカバレッジの確認**
   - 主要な機能がテストでカバーされているか確認
   - 必要に応じて追加のテストケースを作成

2. **コード品質の確認**
   - Linterやフォーマッターを実行（例：ESLint、Prettier）
   - 型チェックを実行（TypeScriptの場合）

3. **ブラウザでの動作確認**
   - 実際にブラウザで動作を確認
   - 異なるブラウザやデバイスサイズでテスト（必要に応じて）

4. **ユーザーへの報告**
   - 実装した内容を簡潔に報告
   - テスト結果を共有
   - 次のステップや追加で必要な作業があれば提案

## テストの規約

このスキルでは、以下のテスト規約に従う：

1. **テスト対象の選定**
   - 複数のコンポーネントがある場合、機能単位で最も大きいコンポーネントにのみテストを書く
   - 小さい子コンポーネントは、親コンポーネントのテストを通じて間接的にテストされる

2. **モックの最小化**
   - APIアクセスとルーター以外は基本的にモックしない
   - 実際の動作に近い状態でテストを行い、統合的な品質を保証する
   - モックが必要な場合も、最小限に抑える

3. **テストの粒度**
   - ユーザーの視点からテストを書く（実装の詳細ではなく、振る舞いをテスト）
   - Testing Libraryのベストプラクティスに従う

## プロジェクト固有の慣習

このスキルを効果的に使用するには、プロジェクト固有の慣習を理解する必要がある。

### プロジェクトローカルの skill の活用

プロジェクトローカルの `${pwd}/.claude/skills/component-tdd/references/project-convention.md` には、以下のような情報が含まれる：

- コンポーネントのディレクトリ構造
- 命名規則（ファイル名、クラス名、変数名など）
- HTML/CSSの慣習（クラス名の付け方、スタイリング手法など）
- テストファイルの配置と命名規則
- 使用しているライブラリとその設定
- アクセシビリティガイドライン
- パフォーマンス最適化のベストプラクティス

このファイルが存在しない場合は、`/fit-to-project component-tdd` コマンドを実行してプロジェクト固有の skill を作成する。

## リソース

### プロジェクトローカル: ${pwd}/.claude/skills/component-tdd/

- `references/project-convention.md`: プロジェクト固有のHTML/CSS慣習、コンポーネント設計パターン、テストパターンを記載
- その他のプロジェクト固有のリソース

### マーケットプレイス: このスキル

- `references/project-convention.md`: テンプレート（プロジェクト固有の skill 作成時に使用）

プロジェクトローカルの skill が作成されている場合は、そちらの references を優先的に参照する。
